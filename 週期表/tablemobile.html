<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>元素週期表滑塊拼圖 (最終穩定版)</title>
<style>
  body {
    font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
    background: #f5f7fa;
    text-align: center;
    color: #1f2937;
    /* 允許原生滾動（避免阻止手機滑動頁面） */
    touch-action: auto;
    /* 支援 iOS 安全區，避免底部被 Home indicator 擋住 */
    padding-bottom: env(safe-area-inset-bottom);
    -webkit-padding-end: env(safe-area-inset-bottom);
  }
  h1 { margin-top: 20px; font-size: 1.5em; }
  #level-selection { margin: 15px 0; }
  .level-btn { padding: 10px 16px; font-size: 1em; cursor: pointer; border: 2px solid transparent; background-color: #6d28d9; color: white; border-radius: 6px; margin: 0 5px; transition: all 0.2s; }
  .level-btn:hover { background-color: #5b21b6; }
  .level-btn.active { background-color: #f5f7fa; color: #6d28d9; border-color: #6d28d9; font-weight: bold; }
  #stats { margin: 15px; font-size: 1.1em; font-weight: bold; color: #374151; }
  #stats span { margin: 0 10px; min-width: 100px; display: inline-block; }
  #controls { margin-top: 10px; }
  #toggleLangBtn { padding: 8px 14px; font-size: 1em; cursor: pointer; border: none; background-color: #4f46e5; color: white; border-radius: 6px; }
  #holding-bay-container { margin: 15px auto; padding: 10px; background: #e5e7eb; border-radius: 8px; display: flex; align-items: center; justify-content: center; width: 200px; }
  #holding-bay-container span { font-weight: bold; margin-right: 10px; }
  #holding-bay { width: 50px; height: 50px; border: 2px dashed #9ca3af; display:flex; align-items:center; justify-content:center; border-radius:6px; user-select:none; }
  #table { display: grid; grid-template-columns: repeat(18, 48px); grid-template-rows: repeat(4, 48px); gap: 2px; justify-content: center; margin: 10px auto; padding: 5px; border: 2px solid #d1d5db; background:#fff; border-radius:8px; width: max-content; }
  .cell { display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: bold; user-select: none; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width:48px; min-height:48px; }
  .cell.empty { background: #e2e8f0; box-shadow: inset 0 2px 4px rgba(0,0,0,0.06); cursor: default; }
  .disabled { background-color: #cbd5e1; cursor: not-allowed; box-shadow: none; }
  .metal { background: #c7f9cc; } .nonmetal { background: #fef08a; } .noble { background: #a5f3fc; } .transition { background: #fca5a5; }
  .clickable { cursor: pointer; }
  .drag-over { outline: 2px dashed #6366f1; transform: scale(1.03); }
  .win-flash { animation: flash 0.5s ease-in-out; }
  @keyframes flash { 0% { box-shadow: 0 0 15px #fef08a; transform: scale(1.05); } 100% { box-shadow: 0 1px 3px rgba(0,0,0,0.1); transform: scale(1); } }
</style>
</head>
<body>
  <h1 id="game-title">🧩 元素週期表滑塊拼圖</h1>
  <div id="level-selection">
    <button class="level-btn" data-level="1">關卡一</button>
    <button class="level-btn" data-level="2">關卡二</button>
    <button class="level-btn" data-level="3">關卡三</button>
    <button class="level-btn" data-level="4">關卡四</button>
  </div>
  <div id="stats">
    <span id="moves">移動步數: 0</span>
    <span id="time">花費時間: 00:00</span>
  </div>
  <div id="controls"><button id="toggleLangBtn">🌐 切換語言</button></div>
  <div id="holding-bay-container"><span>暫存區:</span><div id="holding-bay" class="cell empty" aria-label="暫存區" role="button"></div></div>
  <div id="table"></div>

  <script>
    const allElements = [
      {cn:"氫", en:"H", row:1, col:1, type:"nonmetal"}, {cn:"氦", en:"He", row:1, col:18, type:"noble"},
      {cn:"鋰", en:"Li", row:2, col:1, type:"metal"}, {cn:"鈹", en:"Be", row:2, col:2, type:"metal"},
      {cn:"硼", en:"B", row:2, col:13, type:"nonmetal"}, {cn:"碳", en:"C", row:2, col:14, type:"nonmetal"},
      {cn:"氮", en:"N", row:2, col:15, type:"nonmetal"}, {cn:"氧", en:"O", row:2, col:16, type:"nonmetal"},
      {cn:"氟", en:"F", row:2, col:17, type:"nonmetal"}, {cn:"氖", en:"Ne", row:2, col:18, type:"noble"},
      {cn:"鈉", en:"Na", row:3, col:1, type:"metal"}, {cn:"鎂", en:"Mg", row:3, col:2, type:"metal"},
      {cn:"鋁", en:"Al", row:3, col:13, type:"metal"}, {cn:"矽", en:"Si", row:3, col:14, type:"nonmetal"},
      {cn:"磷", en:"P", row:3, col:15, type:"nonmetal"}, {cn:"硫", en:"S", row:3, col:16, type:"nonmetal"},
      {cn:"氯", en:"Cl", row:3, col:17, type:"nonmetal"}, {cn:"氬", en:"Ar", row:3, col:18, type:"noble"},
      {cn:"鉀", en:"K", row:4, col:1, type:"metal"}, {cn:"鈣", en:"Ca", row:4, col:2, type:"metal"},
      {cn:"鈧", en:"Sc", row:4, col:3, type:"transition"}, {cn:"鈦", en:"Ti", row:4, col:4, type:"transition"},
      {cn:"釩", en:"V", row:4, col:5, type:"transition"}, {cn:"鉻", en:"Cr", row:4, col:6, type:"transition"},
      {cn:"錳", en:"Mn", row:4, col:7, type:"transition"}, {cn:"鐵", en:"Fe", row:4, col:8, type:"transition"},
      {cn:"鈷", en:"Co", row:4, col:9, type:"transition"}, {cn:"鎳", en:"Ni", row:4, col:10, type:"transition"},
      {cn:"銅", en:"Cu", row:4, col:11, type:"transition"}, {cn:"鋅", en:"Zn", row:4, col:12, type:"transition"},
      {cn:"鎵", en:"Ga", row:4, col:13, type:"metal"}, {cn:"鍺", en:"Ge", row:4, col:14, type:"nonmetal"},
      {cn:"砷", en:"As", row:4, col:15, type:"nonmetal"}, {cn:"硒", en:"Se", row:4, col:16, type:"nonmetal"},
      {cn:"溴", en:"Br", row:4, col:17, type:"nonmetal"}, {cn:"氪", en:"Kr", row:4, col:18, type:"noble"},
    ];

    const levels = {
        1: { title: "關卡一：元素新星", filter: el => el.row <= 2 },
        2: { title: "關卡二：主族精通", filter: el => el.row <= 3 },
        3: { title: "關卡三：過渡金屬", filter: el => el.row === 4 },
        4: { title: "關卡四：終極挑戰", filter: el => true }
    };

    const totalRows = 4, totalCols = 18;
    const table = document.getElementById("table");
    const holdingBay = document.getElementById("holding-bay");
    
    let currentLang = "cn", moves = 0, seconds = 0;
    let timerInterval = null, isGameActive = false;
    let currentLevelElements = [];
    let holdingBayElement = null; // 追蹤暫存區的元素資料

    // 判斷是否相鄰 (包含跨越規則)
    function isAdjacent(fromIndex, toIndex) {
        const fromRow = Math.floor(fromIndex / totalCols), fromCol = fromIndex % totalCols;
        const toRow = Math.floor(toIndex / totalCols), toCol = toIndex % totalCols;

        // 規則1: 上下左右相鄰
        if (Math.abs(fromRow - toRow) + Math.abs(fromCol - toCol) === 1) {
            return true;
        }
        // 規則2: 跨越鴻溝 (同橫列)
        if (fromRow === toRow) {
            if (fromRow === 0 && ((fromCol === 0 && toCol === 17) || (fromCol === 17 && toCol === 0))) { // H <-> He
                return true;
            }
            if ((fromRow === 1 || fromRow === 2) && ((fromCol === 1 && toCol === 12) || (fromCol === 12 && toCol === 1))) { // Be <-> B, Mg <-> Al
                return true;
            }
        }
        return false;
    }

    // 渲染或更新一個格子
    function renderCell(cell, elementData) {
        cell.className = `cell ${elementData.type} clickable`;
        cell.textContent = (currentLang === "cn") ? elementData.cn : elementData.en;
        cell.dataset.symbol = elementData.en;
        cell.dataset.cn = elementData.cn;
        cell.dataset.type = elementData.type;
        cell.classList.remove('empty');
    }

    // 清空一個格子
    function clearCell(cell) {
        cell.className = 'cell empty';
        cell.textContent = '';
        cell.dataset.symbol = '';
        cell.dataset.cn = '';
        delete cell.dataset.type;
    }

    // 取得所有在當前關卡範圍內的互動格子（非 disabled）
    function interactiveCells() {
        return Array.from(table.querySelectorAll('.cell:not(.disabled)'));
    }

    // 取得指定 index 的 cell
    function cellByIndex(index) {
        return table.querySelector(`.cell[data-index="${index}"]`);
    }

    // 判斷 cell 是否為空
    function isCellEmpty(cell) {
        return cell && cell.classList.contains('empty') && !cell.classList.contains('disabled');
    }

    // 找到任一空格（回傳 DOM 或 null）
    function findAnyEmptyCell() {
        const empty = table.querySelector('.cell.empty:not(.disabled)');
        return empty || null;
    }

    // 找到某個格子（來源）的鄰近空格（若有）回傳 DOM，沒有則回 null
    function findAdjacentEmptyForCell(sourceCell) {
        if (!sourceCell || sourceCell.classList.contains('empty')) return null;
        const fromIndex = parseInt(sourceCell.dataset.index, 10);
        const all = interactiveCells();
        for (const c of all) {
            const toIndex = parseInt(c.dataset.index, 10);
            if (isCellEmpty(c) && isAdjacent(fromIndex, toIndex)) return c;
        }
        return null;
    }

    // 將一個 cell 的元素資料複製到另一個 cell（不處理暫存區）
    function copyCellToCell(srcCell, dstCell) {
        dstCell.dataset.symbol = srcCell.dataset.symbol;
        dstCell.dataset.cn = srcCell.dataset.cn;
        dstCell.dataset.type = srcCell.dataset.type;
        dstCell.textContent = (currentLang === "cn") ? dstCell.dataset.cn : dstCell.dataset.symbol;
        dstCell.className = `cell ${dstCell.dataset.type} clickable`;
    }

    // 處理從盤面格子移到暫存區
    function moveCellToHoldingBay(srcCell) {
        if (!isCellEmpty(holdingBay)) return false;
        // 建立 holdingBayElement 資料
        holdingBayElement = {
            cn: srcCell.dataset.cn,
            en: srcCell.dataset.symbol,
            type: srcCell.dataset.type
        };
        renderCell(holdingBay, { cn: holdingBayElement.cn, en: holdingBayElement.en, type: holdingBayElement.type });
        // 把來源清空
        clearCell(srcCell);
        incrementMoves();
        return true;
    }

    // 處理從暫存區移回盤面（放到指定目標格）
    function moveHoldingBayToCell(targetCell) {
        if (!holdingBayElement) return false;
        if (!isCellEmpty(targetCell)) return false;
        renderCell(targetCell, { cn: holdingBayElement.cn, en: holdingBayElement.en, type: holdingBayElement.type });
        // 清空 holding bay
        clearCell(holdingBay);
        holdingBayElement = null;
        incrementMoves();
        checkWin();
        return true;
    }

    // 處理兩個盤面格子的移動（來源到目標）
    function moveCellToCell(srcCell, targetCell) {
        if (!isCellEmpty(targetCell)) return false;
        copyCellToCell(srcCell, targetCell);
        clearCell(srcCell);
        incrementMoves();
        checkWin();
        return true;
    }

    // 點擊格子的主要處理流程（取代拖放行為）
    function onCellClick(e) {
        const cell = e.currentTarget;
        // 如果點擊的是 disabled 或空格，忽略（空格點擊可用於把暫存區填回）
        if (cell.classList.contains('disabled')) return;
        // 如果點擊的是空格且暫存區有元素 -> 把暫存區元素放回該空格
        if (isCellEmpty(cell)) {
            // 若暫存區有元素，且點擊空格，則嘗試把暫存區元素放到此空格
            if (holdingBayElement) {
                moveHoldingBayToCell(cell);
            }
            return;
        }
        // 點擊的是有元素的盤面格子
        // 1) 如果有相鄰空格 -> 移動到該相鄰空格（第一個找到的）
        const adj = findAdjacentEmptyForCell(cell);
        if (adj) {
            moveCellToCell(cell, adj);
            return;
        }
        // 2) 如果沒有相鄰空格，且盤面完全滿（沒有空格），則把此元素移到暫存區（前提暫存區空）
        const anyEmpty = findAnyEmptyCell();
        if (!anyEmpty) {
            // board is full
            if (isCellEmpty(holdingBay)) {
                moveCellToHoldingBay(cell);
                return;
            } else {
                flashCell(cell);
                return;
            }
        }
        // 3) 沒有相鄰空格但盤面有其他空格 -> 不允許直接跳到非相鄰的空格（可以做提示）
        flashCell(cell);
    }

    // 點擊暫存區的處理：若暫存區有元素，嘗試放到盤面上的第一個空格（或最近的空格）
    function onHoldingBayClick() {
        if (!holdingBayElement) return;
        // 找到第一個可放的空格（按 index 順序）
        const target = findAnyEmptyCell();
        if (target) {
            moveHoldingBayToCell(target);
        } else {
            flashCell(holdingBay);
        }
    }

    // 簡單閃爍提示（用於無效操作）
    function flashCell(cell) {
        cell.style.transition = 'transform 110ms ease';
        cell.style.transform = 'translateY(-6px)';
        setTimeout(()=>{ cell.style.transform = ''; }, 160);
        setTimeout(()=>{ cell.style.transition = ''; }, 260);
    }

    // 為單個格子設置點擊事件（取代原先拖放與觸控邏輯）
    function setEvents(tile) {
        if (tile.classList.contains('disabled')) return;
        // 一般滑鼠/點擊
        tile.addEventListener('click', onCellClick);

        // 手機: 使用 touchend 但不要 preventDefault()（以免阻止頁面滾動）
        tile.addEventListener('touchend', function (e) {
            // 不阻止預設滾動行為，避免無法向下滑動整個頁面
            e.stopPropagation(); // 防止冒泡造成重複處理，但不呼叫 preventDefault()
            onCellClick.call(this, e);
        }, { passive: true });
    }

    // 創建或更新遊戲盤面
    function createTable(elementOrder, levelConfig) {
        table.innerHTML = "";
        const levelPositions = new Set(levelConfig.map(el => (el.row - 1) * totalCols + (el.col - 1)));
        
        // 使用一個陣列來表示盤面的當前狀態
        const gridState = Array(totalRows * totalCols).fill(null);
        elementOrder.forEach(el => {
            const index = (el.row - 1) * totalCols + (el.col - 1);
            gridState[index] = el;
        });

        for (let i = 0; i < gridState.length; i++) {
            const div = document.createElement("div");
            div.classList.add("cell");
            div.dataset.index = i;

            if (!levelPositions.has(i)) { // 不屬於當前關卡的格子
                div.classList.add("disabled");
            } else {
                const el = gridState[i];
                if (el) { // 如果有元素
                    renderCell(div, el);
                } else { // 空格
                    clearCell(div);
                }
                setEvents(div); // 為每個可互動的格子設置事件
            }
            table.appendChild(div);
        }
    }
    
    // 遊戲開始時的初始化，打亂元素
    function startLevel(levelNum) {
        // 更新關卡按鈕樣式和標題
        document.querySelectorAll('.level-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.level == levelNum);
        });
        document.getElementById("game-title").textContent = levels[levelNum].title;
        
        // 篩選出當前關卡的元素
        currentLevelElements = allElements.filter(levels[levelNum].filter);

        // 打亂元素並創建初始盤面
        let shuffledElements = [...currentLevelElements].sort(() => Math.random() - 0.5);
        let boardSetup = [];
        
        // 將打亂後的元素，按照它們在當前關卡中的"正確"位置放回去
        const elementMap = new Map();
        currentLevelElements.forEach((el, index) => {
            elementMap.set((el.row - 1) * totalCols + (el.col - 1), shuffledElements[index]);
        });

        currentLevelElements.forEach(el => {
            const originalIndex = (el.row - 1) * totalCols + (el.col - 1);
            const shuffledEl = elementMap.get(originalIndex);
            boardSetup.push({ ...shuffledEl, row: el.row, col: el.col });
        });

        // 清空暫存區並創建盤面
        clearCell(holdingBay);
        holdingBayElement = null;
        createTable(boardSetup, currentLevelElements);
        
        startTimerAndCounter();
    }
    
    // 檢查遊戲是否勝利
    function checkWin() {
        if (holdingBayElement) return; // 暫存區必須是空的才算勝利

        const cells = [...table.querySelectorAll(".cell:not(.empty):not(.disabled)")];
        if (cells.length !== currentLevelElements.length) return; // 盤面元素數量必須等於關卡總數

        const isCorrect = cells.every(cell => {
            const el = allElements.find(e => e.en === cell.dataset.symbol);
            const idx = parseInt(cell.dataset.index, 10);
            const row = Math.floor(idx / totalCols) + 1;
            const col = (idx % totalCols) + 1;
            return el && el.row === row && el.col === col;
        });

        if (isCorrect) {
            stopGame();
            // 勝利動畫效果
            cells.forEach(cell => cell.classList.add('win-flash'));
            setTimeout(() => {
                const timeText = document.getElementById("time").textContent.replace('花費時間: ', '');
                alert(`🎯 恭喜完成！\n\n${document.getElementById("game-title").textContent}\n花費時間: ${timeText}\n移動步數: ${moves}`);
                init();
            }, 500); // 延遲顯示訊息，讓動畫有時間播放
        }
    }
    
    // 遊戲初始化/重置
    function init() {
        stopGame();
        isGameActive = false;
        holdingBayElement = null;
        document.getElementById("game-title").textContent = '🧩 元素週期表滑塊拼圖';
        moves = 0; seconds = 0;
        document.getElementById("moves").textContent = '移動步數: 0';
        document.getElementById("time").textContent = '花費時間: 00:00';
        document.querySelectorAll('.level-btn').forEach(btn => btn.classList.remove('active'));
        clearCell(holdingBay);
        createTable([], allElements); // 顯示一個全鎖定的空盤面
    }

    // --- 其他輔助函數 ---
    function startTimerAndCounter() {
        isGameActive = true; moves = 0; seconds = 0;
        document.getElementById("moves").textContent = `移動步數: ${moves}`;
        clearInterval(timerInterval);
        timerInterval = setInterval(() => { seconds++; updateTime(); }, 1000);
        updateTime();
    }
    function stopGame() { isGameActive = false; clearInterval(timerInterval); }
    function incrementMoves() { moves += 1; document.getElementById("moves").textContent = `移動步數: ${moves}`; }
    function updateTime() {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        document.getElementById("time").textContent = `花費時間: ${mins}:${secs}`;
    }

    // 語言切換
    document.getElementById("toggleLangBtn").addEventListener("click", () => {
      currentLang = (currentLang === "cn") ? "en" : "cn";
      // 更新表格與暫存區文字
      document.querySelectorAll(".cell").forEach(cell => {
        if (!cell.classList.contains("empty") && !cell.classList.contains("disabled") && cell.dataset.cn) {
          cell.textContent = (currentLang === "cn") ? cell.dataset.cn : cell.dataset.symbol;
        }
      });
    });

    // 關卡按鈕
    document.querySelectorAll('.level-btn').forEach(button => {
        button.addEventListener("click", () => startLevel(button.dataset.level));
    });

    // 暫存區點擊事件（放回盤面第一個空格）
    holdingBay.addEventListener('click', onHoldingBayClick);
    holdingBay.addEventListener('touchend', function(e){
      // 不 preventDefault，避免阻止頁面滾動
      e.stopPropagation();
      onHoldingBayClick.call(this, e);
    }, { passive: true });

    // 初始化遊戲
    init();
  </script>
</body>
</html>
