<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è²“ç‹—å¤§æˆ°éŠæˆ²</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #ffcc00, #ff99cc, #66ccff);
            background-size: 400% 400%;
            animation: gradientBackground 15s ease infinite;
        }

        @keyframes gradientBackground {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
            background-color: #f0f0f0;
        }

        #health-bars {
            display: flex;
            justify-content: space-between;
            width: 900px;
            margin: 10px auto;
            position: relative;
        }

        #score-display {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            margin: 10px auto;
            width: 300px;
        }

        .health-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 45%;
            position: relative;
        }

        .health-bar {
            height: 40px;
            position: absolute;
            border-radius: 5px;
            background: linear-gradient(145deg, #ff4d4d, #b30000);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            border: 2px solid black;
        }

        .health-bar-background {
            width: 100%;
            height: 40px;
            background: linear-gradient(145deg, #f0f0f0, #d9d9d9);
            position: relative;
            border-radius: 5px;
            box-shadow: inset 0 2px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        #cat-health {
            right: 0;
            background: linear-gradient(145deg, #b30000, #ff4d4d);
        }

        #dog-health {
            left: 0;
        }

        #game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }

        #game-over h2 {
            font-size: 100px;
            color: red;
            font-weight: bold;
        }

        #game-over button {
            padding: 10px 20px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
        }

        #game-over button:hover {
            background-color: #45a049;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        #game-title {
            text-align: center;
            position: fixed;
            bottom: 0;
            width: 100%;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 0;
        }

        #generator-screen {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 900px;
            /* èˆ‡éŠæˆ²å€å¯¬åº¦ç›¸åŒ */
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid black;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #generator-screen h1 {
            margin-bottom: 20px;
        }

        #generator-input {
            width: 100%;
            height: 100px;
            margin-bottom: 20px;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #generator-submit,
        #start-game,
        #download-game {
            padding: 10px 20px;
            font-size: 18px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #generator-submit:hover,
        #start-game:hover,
        #download-game:hover {
            background-color: #45a049;
        }

        #output-table {
            margin-top: 20px;
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            max-height: 300px;
            /* é™åˆ¶é«˜åº¦ä»¥æ”¯æŒæ²å‹• */
            overflow-y: auto;
            /* å‚ç›´æ²å‹• */
            display: block;
        }

        #output-table thead {
            position: sticky;
            top: 0;
            background-color: #f1f1f1;
        }

        #output-table th,
        #output-table td {
            border: 1px solid black;
            padding: 10px;
            text-align: left;
        }

        #start-game {
            display: none;
            margin-top: 20px;
        }

        #question-layer {
            display: none;
            position: fixed;
            top: 2%;
            left: 50%;
            transform: translateX(-50%);
            width: 98vw;
            max-width: 950px;
            height: 96vh;
            background-color: #e6ffe6;
            border: 2px solid black;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            z-index: 1500;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        #question-layer h2 {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
            text-shadow: 1px 1px 2px #ffffff;
            background: rgba(255, 255, 255, 0.6);
            padding: 10px;
            border-radius: 10px;
            margin: 0 0 5px 0;
        }

        #question-image {
            width: 90vw;
            max-width: 800px;
            height: 60vh;
            max-height: 600px;
            min-width: 400px;
            min-height: 300px;
            object-fit: contain;
            border: 3px solid #2c3e50;
            border-radius: 10px;
            background-color: white;
            margin: 5px auto;
            display: block;
        }

        .option-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }

        .option-buttons button {
            padding: 15px;
            font-size: 24px;
            color: white;
            font-weight: bold;
            margin-bottom: 15px;
            width: calc(100% - 30px);
            height: 80px;
            background: #1abc9c;
            border: none;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .option-buttons button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: rgba(255, 255, 255, 0.15);
            transition: all 0.75s ease-in-out;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
        }

        .option-buttons button:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }

        .option-buttons button:hover {
            background: #16a085;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .option-buttons button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .option-buttons button:hover::after {
            opacity: 1;
        }

        /* æ–°å¢çš„é€æ˜é»æ“Šå€ */
        #secret-trigger {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 50px;
            height: 50px;
            background-color: transparent;
            z-index: 9999;
        }

        /* æ–°å¢çš„å³ä¸‹è§’æ–‡å­—å€åŸŸ */
        #footer-text {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 14px;
            color: white;
        }
    </style>
</head>

<body>
    <div id="score-display">
        ç©å®¶å‘½ä¸­æ¬¡æ•¸: <span id="hit-count">0</span> | é€£çºŒç­”å°: <span id="streak-count">0</span>
    </div>
    <div id="health-bars">
        <div class="health-bar-background">
            <span class="health-bar" id="cat-health" style="width: 60%;">è²“çš„è¡€é‡: 60</span>
            <span>è²“çš„è¡€é‡</span>
        </div>
        <div class="health-bar-background">
            <span class="health-bar" id="dog-health" style="width: 80%;">ç‹—çš„è¡€é‡: 80</span>
            <span>ç‹—çš„è¡€é‡</span>
        </div>
    </div>
    <canvas id="gameCanvas" width="900" height="650"></canvas>
    <div id="game-over"></div>
    <div id="game-title">è²“ç‹—å¤§æˆ°éŠæˆ² - ç­”å°æ”»æ“Šï¼Œç­”éŒ¯è¢«æ”»æ“Šï¼</div>
    <div id="toggle-generator"></div>
    <div id="generator-screen" style="display: none;">
        <h1>è²“ç‹—å¤§æˆ°éŠæˆ²ç”Ÿæˆå™¨</h1>
        <textarea id="generator-input" placeholder="è¼¸å…¥é¡Œç›®ï¼Œè«‹ç”¨é€—è™Ÿæˆ–åˆ¶è¡¨ç¬¦åˆ†éš”å„åˆ—..."></textarea><br>
        <button id="generator-submit">é€å‡º</button>
        <button id="start-game" style="display: inline-block;">é–‹å§‹éŠç©</button>
        <button id="download-game">ä¸‹è¼‰å®Œæ•´éŠæˆ²</button>
        <table id="output-table">
            <thead>
                <tr>
                    <th>é¡Œç›®</th>
                    <th>ç­”æ¡ˆ</th>
                    <th>é¸é …1</th>
                    <th>é¸é …2</th>
                    <th>é¸é …3</th>
                    <th>é¸é …4</th>
                </tr>
            </thead>

        </table>
    </div>
    <div id="question-layer" style="display: none;">
        <h2 id="question-text">è«‹çœ‹åœ–ç‰‡é¸æ“‡ç­”æ¡ˆ</h2>
        <img id="question-image" src="pic709/ä¸­.png" alt="é¡Œç›®åœ–ç‰‡">
        <div class="option-buttons" id="player-options" style="width: 100%; margin: 0 auto;">
            <button style="background-color: red;">ä¸­</button>
            <button style="background-color: green;">å±±</button>
            <button style="background-color: blue;">7</button>
            <button style="background-color: purple;">0</button>
        </div>
    </div>

    <!-- æ–°å¢çš„é€æ˜é»æ“Šå€ -->
    <div id="secret-trigger"></div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverDiv = document.getElementById('game-over');
        const questionLayer = document.getElementById('question-layer');
        const questionText = document.getElementById('question-text');
        const playerOptions = document.getElementById('player-options');

        let gamePaused = false;
        let questionData = [];
        let usedQuestions = [];
        let currentQuestionIndex = -1;
        let catCanThrow = false;
        let dogCanThrow = false;
        let computerAttacking = false;
        let questionsLoaded = false;
        let playerHitCount = 0; // ç©å®¶å‘½ä¸­æ¬¡æ•¸
        let correctStreak = 0; // é€£çºŒç­”å°æ¬¡æ•¸
        let hasShield = false; // æ˜¯å¦æœ‰è­·ç›¾
        let bigBullet = false; // æ˜¯å¦æœ‰å¤§å­å½ˆ

        // é›»è…¦è§’è‰²emojiåˆ—è¡¨ï¼ˆä¸åŒ…å«è²“ï¼‰
        const computerCharacters = ['ğŸ¶', 'ğŸº', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ¸', 'ğŸ·'];
        let currentComputerCharacter = computerCharacters[0]; // ç•¶å‰é›»è…¦è§’è‰²

        const cat = {
            x: 60,
            y: canvas.height - 50,
            baseY: canvas.height - 50, // åœ°é¢ä½ç½®
            health: 100,
            size: 100,
            hitboxRadius: 55,
            power: 5,
            angle: 0,
            rotation: 0,
            targetRotation: 0,
            isJumping: false,
            jumpVelocity: 0
        };
        const dog = {
            x: canvas.width - 60 - 100,
            y: canvas.height - 50,
            health: 100,
            size: 100,
            hitboxRadius: 55,
            power: 5,
            angle: 0,
            rotation: 0,
            targetRotation: 0
        };
        const gravity = 0.5;
        const projectileWidth = 45;
        const projectileHeight = 15;
        const projectileColors = ['red', 'green', 'blue', 'purple'];
        const bounceFactor = 0.7;
        let projectiles = [];
        let flowers = [];
        let flyingTexts = [];
        let currentCharacter = null;
        let currentCharacterType = null;
        let powerInterval = null;
        let angleInterval = null;
        let isSettingPower = false;
        let isSettingAngle = false;
        let gameEnded = false;

        function drawBackground() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);

            ctx.fillStyle = '#32CD32';
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

            drawSunset(canvas.width - 100, 100);

            ctx.fillStyle = '#B22222';
            ctx.fillRect(100, canvas.height / 2 - 150, 200, 150);

            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(100, canvas.height / 2 - 150);
            ctx.lineTo(200, canvas.height / 2 - 250);
            ctx.lineTo(300, canvas.height / 2 - 150);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#654321';
            ctx.fillRect(180, canvas.height / 2 - 80, 40, 80);

            ctx.fillStyle = '#ADD8E6';
            ctx.fillRect(120, canvas.height / 2 - 130, 30, 30);
            ctx.fillRect(250, canvas.height / 2 - 130, 30, 30);

            drawBigTree(650, canvas.height / 2);

            drawTree(450, canvas.height / 2);
            drawTree(750, canvas.height / 2);

            drawCloud(200, 100);
            drawCloud(700, 130);

            drawBird(400, 150);
            drawBird(500, 180);

            drawFlowers();

            drawFence();

            ctx.font = '30px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText('', 300, 50);
        }

        function drawTree(x, y) {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y - 50, 20, 50);

            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x + 10, y - 60, 30, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBigTree(x, y) {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 20, y - 100, 40, 100);

            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y - 130, 60, 0, Math.PI * 2);
            ctx.arc(x - 50, y - 100, 40, 0, Math.PI * 2);
            ctx.arc(x + 50, y - 100, 40, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCloud(x, y) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 30, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 60, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBird(x, y) {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 10, y + 5);
            ctx.lineTo(x, y + 10);
            ctx.lineTo(x - 10, y + 5);
            ctx.closePath();
            ctx.fill();
        }

        function drawSunset(x, y) {
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.arc(x, y, 50, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            for (let i = 0; i < 12; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + 100 * Math.cos(Math.PI * i / 6), y + 100 * Math.sin(Math.PI * i / 6));
                ctx.stroke();
            }

            ctx.fillStyle = 'rgba(255, 223, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x - 50, y);
            ctx.lineTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(x + 50, y);
            ctx.closePath();
            ctx.fill();
        }

        function generateRandomFlowers() {
            const flowerColors = ['red', 'yellow', 'blue', 'purple', 'pink', 'orange', 'white'];
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height / 2 + Math.random() * (canvas.height / 2 - 30);
                const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                flowers.push({ x, y, color });
            }
        }

        function drawFlowers() {
            for (const flower of flowers) {
                drawFlower(flower.x, flower.y, flower.color);
            }
        }

        function drawFlower(x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawFence() {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(canvas.width / 2 - 10, canvas.height - 240, 20, 240);

            ctx.fillStyle = '#654321';
            for (let i = 0; i < 8; i++) {
                ctx.fillRect(canvas.width / 2 - 20, canvas.height - 240 + i * 30, 40, 5);
            }
        }

        function drawCharacters() {
            // ç¹ªè£½è²“å’ªè­·ç›¾
            if (hasShield) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(cat.x + 50, cat.y - 40, cat.hitboxRadius + 15, 0, Math.PI * 2);
                ctx.fill();

                // è­·ç›¾é–ƒçˆæ•ˆæœ
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cat.x + 50, cat.y - 40, cat.hitboxRadius + 15, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.save();
            ctx.translate(cat.x + 50, cat.y - 50);
            ctx.rotate(cat.rotation * Math.PI / 180);
            ctx.translate(-(cat.x + 50), -(cat.y - 50));
            ctx.font = "100px Arial";
            ctx.fillText("ğŸ˜º", cat.x, cat.y);
            ctx.restore();

            ctx.save();
            ctx.translate(dog.x + 50, dog.y - 50);
            ctx.rotate(dog.rotation * Math.PI / 180);
            ctx.translate(-(dog.x + 50), -(dog.y - 50));
            ctx.font = "100px Arial";
            ctx.fillText(currentComputerCharacter, dog.x, dog.y);
            ctx.restore();

            if (currentCharacter) {
                ctx.font = "18px Arial";
                if (isSettingPower) {
                    // ä¿®æ”¹åŠ›é‡ç›´æ¢åœ–çš„æ¨£å¼
                    ctx.fillStyle = 'lightgray';
                    ctx.fillRect(currentCharacter.x - 20, currentCharacter.y - 280, 20, 132);
                    if (currentCharacter.power > 15) {
                        ctx.fillStyle = 'red';
                    } else {
                        ctx.fillStyle = 'green';
                    }
                    ctx.fillRect(currentCharacter.x - 20, currentCharacter.y - 280 + (132 - (currentCharacter.power - 5) / 20 * 132), 20, (currentCharacter.power - 5) / 20 * 132);
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(currentCharacter.x - 20, currentCharacter.y - 280, 20, 132);

                    // ç•«ä¸€æ¢ç´…ç·šè¡¨ç¤ºåŠ›é‡15çš„ä½ç½®
                    const powerThresholdY = currentCharacter.y - 280 + (132 - (15 - 5) / 20 * 132);
                    ctx.strokeStyle = 'red';
                    ctx.beginPath();
                    ctx.moveTo(currentCharacter.x - 25, powerThresholdY);
                    ctx.lineTo(currentCharacter.x + 5, powerThresholdY);
                    ctx.stroke();

                    // åŠ›é‡ç›´æ¢åœ–çš„å³æ™‚æ–‡å­—
                    ctx.fillStyle = 'red';
                    ctx.fillText(`åŠ›é‡: ${currentCharacter.power}`, currentCharacter.x, currentCharacter.y - 300);
                } else if (isSettingAngle) {
                    ctx.font = "18px Arial"; // ä¿®æ”¹è§’åº¦æ‰‡å½¢åœ–çš„å³æ™‚æ–‡å­—
                    const centerX = currentCharacter.x + 50;
                    const centerY = currentCharacter.y - 140;
                    const radius = 100;

                    if (currentCharacterType === 'cat') {
                        // ä¿®æ”¹è§’åº¦æ‰‡å½¢åœ–çš„æ¨£å¼
                        const angleCenterX = cat.x + 50 + 50;
                        const angleCenterY = cat.y - 40 - 50;
                        ctx.fillStyle = 'red';
                        ctx.beginPath();
                        ctx.moveTo(angleCenterX, angleCenterY);
                        ctx.arc(angleCenterX, angleCenterY, radius, 0, -currentCharacter.angle * Math.PI / 180, true);
                        ctx.lineTo(angleCenterX, angleCenterY);
                        ctx.fill();
                        ctx.strokeStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(angleCenterX, angleCenterY, radius, 0, -currentCharacter.angle * Math.PI / 180, true);
                        ctx.stroke();

                        // è§’åº¦æ‰‡å½¢åœ–çš„å³æ™‚æ–‡å­—
                        ctx.fillStyle = 'red';
                        ctx.fillText(`è§’åº¦: ${currentCharacter.angle}`, angleCenterX + 70, angleCenterY - 70);
                    } else {
                        const angleCenterX = dog.x + 50 - 50;
                        const angleCenterY = dog.y - 40 - 50;
                        ctx.fillStyle = 'red';
                        ctx.beginPath();
                        ctx.moveTo(angleCenterX, angleCenterY);
                        ctx.arc(angleCenterX, angleCenterY, radius, Math.PI, Math.PI + currentCharacter.angle * Math.PI / 180, false);
                        ctx.lineTo(angleCenterX, angleCenterY);
                        ctx.fill();
                        ctx.strokeStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(angleCenterX, angleCenterY, radius, Math.PI, Math.PI + currentCharacter.angle * Math.PI / 180, false);
                        ctx.stroke();

                        // è§’åº¦æ‰‡å½¢åœ–çš„å³æ™‚æ–‡å­—
                        ctx.fillStyle = 'red';
                        ctx.fillText(`è§’åº¦: ${currentCharacter.angle}`, angleCenterX - 130, angleCenterY - 70);
                    }
                }
            }

            ctx.fillStyle = catCanThrow ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.arc(cat.x + 50, cat.y - 40, cat.hitboxRadius, 0, Math.PI * 2);
            ctx.fill();

            // é›»è…¦æ”»æ“Šæ™‚é¡¯ç¤ºç´…è‰²å…‰åœˆ
            if (computerAttacking) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(dog.x + 50, dog.y - 40, dog.hitboxRadius + 10, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = dogCanThrow ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.arc(dog.x + 50, dog.y - 40, dog.hitboxRadius, 0, Math.PI * 2);
            ctx.fill();

            // ç¹ªè£½ç©å®¶æ§åˆ¶ç•Œé¢ï¼ˆç•¶ç©å®¶å¯ä»¥è¡Œå‹•æ™‚ï¼‰
            if (catCanThrow && !isSettingPower && !isSettingAngle) {
                // å·¦ç®­é ­
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.beginPath();
                ctx.moveTo(cat.x - 30, cat.y - 40);
                ctx.lineTo(cat.x - 10, cat.y - 50);
                ctx.lineTo(cat.x - 10, cat.y - 30);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();

                // å³ç®­é ­
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.beginPath();
                ctx.moveTo(cat.x + 130, cat.y - 40);
                ctx.lineTo(cat.x + 110, cat.y - 50);
                ctx.lineTo(cat.x + 110, cat.y - 30);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();

                // æ”»æ“Šå…‰é»ï¼ˆå–ä»£åŸæœ¬é»æ“Šè²“å’ªçš„åŠŸèƒ½ï¼‰
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(cat.x + 50, cat.y - 120, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.stroke();

                // æ”»æ“Šå…‰é»æ–‡å­—
                ctx.fillStyle = 'red';
                ctx.font = '14px Arial';
                ctx.fillText('æ”»æ“Š', cat.x + 35, cat.y - 135);
            }
        }

        // è·³èºåŠŸèƒ½
        function makeCatJump() {
            if (!cat.isJumping) {
                cat.isJumping = true;
                cat.jumpVelocity = -15; // å‘ä¸Šçš„åˆå§‹é€Ÿåº¦
            }
        }

        // ç§»å‹•åŠŸèƒ½
        function moveCat(direction) {
            const moveDistance = 50;
            const leftBoundary = 10; // å·¦é‚Šç•Œ
            const rightBoundary = canvas.width / 2 - cat.size - 20; // å³é‚Šç•Œï¼ˆä¸­é–“åˆ†éš”ç·š - è²“å’ªå¯¬åº¦ - å®‰å…¨è·é›¢ï¼‰

            if (direction === 'left' && cat.x > leftBoundary) {
                cat.x = Math.max(leftBoundary, cat.x - moveDistance);
            } else if (direction === 'right' && cat.x < rightBoundary) {
                cat.x = Math.min(rightBoundary, cat.x + moveDistance);
            }
        }

        // æ›´æ–°è²“å’ªè·³èº
        function updateCatJump() {
            if (cat.isJumping) {
                cat.y += cat.jumpVelocity;
                cat.jumpVelocity += gravity;

                // æª¢æŸ¥æ˜¯å¦å›åˆ°åœ°é¢
                if (cat.y >= cat.baseY) {
                    cat.y = cat.baseY;
                    cat.isJumping = false;
                    cat.jumpVelocity = 0;
                }
            }
        }

        // éš¨æ©Ÿåˆ‡æ›é›»è…¦è§’è‰²
        function changeComputerCharacter() {
            const randomIndex = Math.floor(Math.random() * computerCharacters.length);
            currentComputerCharacter = computerCharacters[randomIndex];
            console.log('é›»è…¦è§’è‰²åˆ‡æ›ç‚º:', currentComputerCharacter);
        }

        function updateHealthBars() {
            const catHealthBar = document.getElementById('cat-health');
            const dogHealthBar = document.getElementById('dog-health');
            catHealthBar.style.width = cat.health + '%';
            catHealthBar.innerText = `è²“çš„è¡€é‡: ${cat.health / 10}`;
            dogHealthBar.style.width = dog.health + '%';
            dogHealthBar.innerText = `ç‹—çš„è¡€é‡: ${dog.health / 10}`;
        }

        function throwObject(character) {
            const radians = character.angle * (Math.PI / 180);
            const vx = character.power * Math.cos(radians);
            const vy = -character.power * Math.sin(radians);
            const color = projectileColors[Math.floor(Math.random() * projectileColors.length)];
            const rotationSpeed = character === cat ? 5 : -5;

            // æ±ºå®šå­å½ˆå¤§å°
            let bulletWidth = projectileWidth;
            let bulletHeight = projectileHeight;
            if (character === cat && bigBullet) {
                bulletWidth = projectileWidth * 2;
                bulletHeight = projectileHeight * 2;
            }

            if (character === cat) {
                projectiles.push({ x: cat.x + cat.size, y: cat.y - cat.size, vx: vx, vy: vy, color: color, from: 'cat', rotation: 0, rotationSpeed: rotationSpeed, width: bulletWidth, height: bulletHeight });
            } else {
                projectiles.push({ x: dog.x, y: dog.y - dog.size, vx: -vx, vy: vy, color: color, from: 'dog', rotation: 0, rotationSpeed: rotationSpeed, width: bulletWidth, height: bulletHeight });
            }

            // é‡ç½®å¤§å­å½ˆç‹€æ…‹
            if (character === cat && bigBullet) {
                bigBullet = false;
                updateScoreDisplay();
            }

            catCanThrow = false;
            dogCanThrow = false;
            computerAttacking = false;
            setTimeout(() => {
                if (!gameEnded) showQuestion();
            }, 2000);
        }

        // é›»è…¦è‡ªå‹•æ”»æ“Šå‡½æ•¸
        // è¨ˆç®—æœ€ä½³æ”»æ“Šåƒæ•¸çš„å‡½æ•¸
        function calculateOptimalAttack() {
            // ç‹—åˆ°è²“çš„è·é›¢å’Œé«˜åº¦å·®
            const distance = Math.abs(cat.x + 50 - (dog.x + 50)); // ç´„680px
            const heightDiff = 0; // åŒä¸€æ°´å¹³ç·š
            const gravity = 0.5;

            // å¹¾å€‹æœ‰æ•ˆçš„æ”»æ“Šçµ„åˆ (è§’åº¦, åŠ›é‡) - ç¶“éè¨ˆç®—çš„æœ€ä½³åƒæ•¸
            const effectiveAttacks = [
                { angle: 45, power: 18 },   // ç¶“å…¸45åº¦è§’
                { angle: 35, power: 20 },   // è¼ƒä½è§’åº¦ï¼Œè¼ƒå¤§åŠ›é‡
                { angle: 55, power: 16 },   // è¼ƒé«˜è§’åº¦ï¼Œè¼ƒå°åŠ›é‡
                { angle: 40, power: 19 },   // å¹³è¡¡çµ„åˆ
                { angle: 50, power: 17 },   // å¦ä¸€å€‹å¹³è¡¡çµ„åˆ
                { angle: 30, power: 22 },   // ä½è§’åº¦å¼·åŠ›æ”»æ“Š
                { angle: 60, power: 15 },   // é«˜è§’åº¦ç²¾æº–æ”»æ“Š
                { angle: 42, power: 18.5 }, // å¾®èª¿çµ„åˆ
                { angle: 48, power: 17.5 }  // å¦ä¸€å€‹å¾®èª¿çµ„åˆ
            ];

            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æœ‰æ•ˆæ”»æ“Šï¼Œä¸¦åŠ å…¥å°‘é‡éš¨æ©Ÿæ€§æé«˜å‘½ä¸­ç‡
            const baseAttack = effectiveAttacks[Math.floor(Math.random() * effectiveAttacks.length)];

            return {
                angle: baseAttack.angle + (Math.random() - 0.5) * 8, // Â±4åº¦çš„éš¨æ©Ÿæ€§
                power: baseAttack.power + (Math.random() - 0.5) * 3   // Â±1.5åŠ›é‡çš„éš¨æ©Ÿæ€§
            };
        }

        function computerAttack() {
            if (gameEnded || computerAttacking) return;

            computerAttacking = true;

            // ä½¿ç”¨è¨ˆç®—å‡ºçš„æœ€ä½³æ”»æ“Šåƒæ•¸ï¼Œå¤§å¹…æé«˜å‘½ä¸­ç‡
            const optimalAttack = calculateOptimalAttack();
            dog.power = Math.max(5, Math.min(25, optimalAttack.power)); // ç¢ºä¿åœ¨5-25ç¯„åœå…§
            dog.angle = Math.max(0, Math.min(90, optimalAttack.angle)); // ç¢ºä¿åœ¨0-90åº¦ç¯„åœå…§

            console.log(`é›»è…¦æ”»æ“Š: è§’åº¦=${dog.angle.toFixed(1)}Â°, åŠ›é‡=${dog.power.toFixed(1)}`);

            // é¡¯ç¤ºé›»è…¦æ”»æ“Šå‹•ç•«
            setTimeout(() => {
                throwObject(dog);
            }, 1000);
        }

        function updateProjectiles() {
            for (let i = 0; i < projectiles.length; i++) {
                let p = projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += gravity;
                p.rotation += p.rotationSpeed;

                if (p.x >= canvas.width / 2 - 10 && p.x <= canvas.width / 2 + 10 && p.y >= canvas.height - 240) {
                    p.vx = -p.vx * bounceFactor;
                    p.vy = p.vy * bounceFactor;
                    p.x += p.vx;
                }

                for (let j = 0; j < flyingTexts.length; j++) {
                    let t = flyingTexts[j];
                    if (p.x >= t.x && p.x <= t.x + t.width && p.y >= t.y - t.height && p.y <= t.y) {
                        p.vy = p.vy * bounceFactor;
                        p.vx = -p.vx * bounceFactor;
                        break;
                    }
                }

                if (p.from === 'cat' && Math.hypot(p.x - (dog.x + 50), p.y - (dog.y - 40)) <= dog.hitboxRadius) {
                    dog.health -= 20;
                    playerHitCount++; // ç©å®¶å‘½ä¸­æ¬¡æ•¸+1
                    updateScoreDisplay();
                    rotateCharacter(dog, 10);
                    projectiles.splice(i, 1);
                    i--;
                } else if (p.from === 'dog' && Math.hypot(p.x - (cat.x + 50), p.y - (cat.y - 40)) <= cat.hitboxRadius) {
                    if (hasShield) {
                        // è­·ç›¾æ“‹ä½æ”»æ“Š
                        hasShield = false;
                        updateScoreDisplay();
                    } else {
                        cat.health -= 20;
                        rotateCharacter(cat, -10);
                    }
                    projectiles.splice(i, 1);
                    i--;
                } else if (p.y > canvas.height) {
                    projectiles.splice(i, 1);
                    i--;
                }
            }
        }

        function rotateCharacter(character, angle) {
            character.targetRotation = character.rotation + angle;
            const rotationStep = angle / 10;

            const rotationInterval = setInterval(() => {
                character.rotation += rotationStep;
                if ((angle > 0 && character.rotation >= character.targetRotation) || (angle < 0 && character.rotation <= character.targetRotation)) {
                    clearInterval(rotationInterval);
                    setTimeout(() => {
                        character.targetRotation = character.rotation - angle;
                        const returnInterval = setInterval(() => {
                            character.rotation -= rotationStep;
                            if ((angle > 0 && character.rotation <= character.targetRotation) || (angle < 0 && character.rotation >= character.targetRotation)) {
                                clearInterval(returnInterval);
                            }
                        }, 10);
                    }, 100);
                }
            }, 10);
        }

        function drawProjectiles() {
            for (let p of projectiles) {
                ctx.save();
                ctx.translate(p.x + p.width / 2, p.y + p.height / 2);
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.width / 2, -p.height / 2, p.width, p.height);
                ctx.restore();
            }
        }

        function checkGameOver() {
            if (cat.health <= 0) {
                // åªæœ‰ç©å®¶è¡€é‡æ­¸é›¶æ‰æœƒéŠæˆ²çµæŸ
                gameEnded = true;
                gameOver('lose');
            } else if (dog.health <= 0) {
                // é›»è…¦è¡€é‡æ­¸é›¶æ™‚è‡ªå‹•æ¢å¾©ï¼ŒéŠæˆ²ç¹¼çºŒï¼Œä¸¦åˆ‡æ›è§’è‰²
                dog.health = 100;
                changeComputerCharacter(); // åˆ‡æ›é›»è…¦è§’è‰²
                updateHealthBars();
                console.log('é›»è…¦è¡€é‡æ¢å¾©ï¼Œè§’è‰²åˆ‡æ›ï¼ŒéŠæˆ²ç¹¼çºŒï¼');
            }
        }

        function gameOver(result) {
            if (result === 'lose') {
                gameOverDiv.innerHTML = `<h2>è¼¸äº†!</h2><p>æœ€çµ‚å‘½ä¸­æ¬¡æ•¸: ${playerHitCount}</p><p>æœ€é«˜é€£çºŒç­”å°: ${Math.max(...(usedQuestions.length > 0 ? [correctStreak] : [0]))}</p><button onclick="restartGame()">é‡æ–°é–‹å§‹</button>`;
            } else {
                // ä¿ç•™åŸæœ‰çš„å‹åˆ©é‚è¼¯ï¼ˆé›–ç„¶ç¾åœ¨ä¸æœƒè§¸ç™¼ï¼‰
                const winnerEmoji = result === 'cat' ? 'ğŸ˜º' : 'ğŸ¶';
                const winnerText = `${winnerEmoji} è´äº†!`;
                gameOverDiv.innerHTML = `<h2>${winnerText}</h2><button onclick="restartGame()">é‡æ–°é–‹å§‹</button>`;
            }
            gameOverDiv.style.display = 'block';
        }

        function restartGame() {
            cat.health = 100;
            cat.x = 60; // é‡ç½®è²“å’ªä½ç½®
            cat.y = cat.baseY; // é‡ç½®åˆ°åœ°é¢
            cat.isJumping = false; // é‡ç½®è·³èºç‹€æ…‹
            cat.jumpVelocity = 0;
            dog.health = 100;
            changeComputerCharacter(); // é‡æ–°é–‹å§‹æ™‚åˆ‡æ›é›»è…¦è§’è‰²
            projectiles = [];
            flowers = [];
            flyingTexts = [];
            usedQuestions = []; // é‡ç½®å·²ä½¿ç”¨çš„é¡Œç›®
            playerHitCount = 0; // é‡ç½®å‘½ä¸­æ¬¡æ•¸
            correctStreak = 0; // é‡ç½®é€£çºŒç­”å°æ¬¡æ•¸
            hasShield = false; // é‡ç½®è­·ç›¾
            bigBullet = false; // é‡ç½®å¤§å­å½ˆ
            generateRandomFlowers();
            gameEnded = false;
            gameOverDiv.style.display = 'none';
            updateScoreDisplay();

            // ç¢ºä¿é¡Œç›®å·²è¼‰å…¥å¾Œæ‰é¡¯ç¤ºé¡Œç›®
            if (questionsLoaded) {
                showQuestion();
            }
            gameLoop();
        }

        function gameLoop() {
            if (gameEnded || gamePaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            updateCatJump(); // æ›´æ–°è²“å’ªè·³èº
            drawCharacters();
            updateProjectiles();
            drawProjectiles();
            drawFlyingTexts();
            updateFlyingTexts();
            updateHealthBars();
            checkGameOver();
            requestAnimationFrame(gameLoop);
        }

        function startPowerSetting(character) {
            if (powerInterval) {
                clearInterval(powerInterval); // æ¸…é™¤ä¹‹å‰çš„è¨ˆæ™‚å™¨
            }
            character.power = 5; // è¨­å®šåŠ›é‡çš„åˆå§‹å€¼
            let increasing = true;
            const minPower = 5; // è¨­å®šæœ€å°åŠ›é‡
            const maxPower = 25; // è¨­å®šæœ€å¤§åŠ›é‡
            const intervalSpeed = 66; // è¨­å®šè®ŠåŒ–é€Ÿåº¦ (æ¯«ç§’)

            powerInterval = setInterval(() => {
                if (increasing) {
                    character.power += 1;
                    if (character.power >= maxPower) {
                        increasing = false;
                    }
                } else {
                    character.power -= 1;
                    if (character.power <= minPower) {
                        increasing = true;
                    }
                }
            }, intervalSpeed);
        }

        function startAngleSetting(character) {
            if (angleInterval) {
                clearInterval(angleInterval); // æ¸…é™¤ä¹‹å‰çš„è¨ˆæ™‚å™¨
            }
            character.angle = 0;
            let increasing = true;
            const minAngle = 0;
            const maxAngle = 90;
            const intervalSpeed = 33;

            angleInterval = setInterval(() => {
                if (increasing) {
                    character.angle += 1;
                    if (character.angle >= maxAngle) {
                        increasing = false;
                    }
                } else {
                    character.angle -= 1;
                    if (character.angle <= minAngle) {
                        increasing = true;
                    }
                }
            }, intervalSpeed);
        }

        function drawFlyingTexts() {
            for (let t of flyingTexts) {
                ctx.font = '30px Arial bold';
                ctx.fillStyle = 'white';
                ctx.fillRect(t.x, t.y - t.height, t.width, t.height);
                ctx.fillStyle = 'red';
                ctx.fillText(t.text, t.x, t.y);
            }
        }

        function updateFlyingTexts() {
            for (let t of flyingTexts) {
                t.x += t.speed;
                if (t.x > canvas.width || t.x + t.width < 0) {
                    flyingTexts.splice(flyingTexts.indexOf(t), 1);
                }
            }
        }

        function generateFlyingText() {
            const texts = ['UFO', 'é£›æ©Ÿ'];
            const text = texts[Math.floor(Math.random() * texts.length)];
            const x = Math.random() < 0.5 ? -50 : canvas.width;
            const y = Math.random() * (canvas.height / 2);
            const speed = (Math.random() * 3 + 1) * (x < 0 ? 1 : -1);
            ctx.font = '30px Arial bold';
            const width = ctx.measureText(text).width;
            const height = 30;
            flyingTexts.push({ text, x, y, speed, width, height });
            setTimeout(generateFlyingText, Math.random() * 20000);
        }

        canvas.addEventListener('click', (event) => {
            if (gameEnded || gamePaused || computerAttacking) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (!isSettingPower && !isSettingAngle) {
                if (catCanThrow) {
                    // é»æ“Šè²“å’ª - è·³èº
                    if (x >= cat.x && x <= cat.x + cat.size && y >= cat.y - cat.size && y <= cat.y) {
                        makeCatJump();
                    }
                    // é»æ“Šå·¦ç®­é ­ - å‘å·¦ç§»å‹•
                    else if (x >= cat.x - 30 && x <= cat.x - 10 && y >= cat.y - 50 && y <= cat.y - 30) {
                        moveCat('left');
                    }
                    // é»æ“Šå³ç®­é ­ - å‘å³ç§»å‹•
                    else if (x >= cat.x + 110 && x <= cat.x + 130 && y >= cat.y - 50 && y <= cat.y - 30) {
                        moveCat('right');
                    }
                    // é»æ“Šæ”»æ“Šå…‰é» - é–‹å§‹æ”»æ“Šè¨­å®š
                    else if (Math.hypot(x - (cat.x + 50), y - (cat.y - 120)) <= 15) {
                        currentCharacter = cat;
                        currentCharacterType = 'cat';
                        isSettingPower = true;
                        startPowerSetting(cat);
                    }
                }
            } else if (isSettingPower && currentCharacterType === 'cat') {
                clearInterval(powerInterval);
                powerInterval = null;
                isSettingPower = false;
                isSettingAngle = true;
                setTimeout(() => {
                    startAngleSetting(currentCharacter);
                }, 1200);
            } else if (isSettingAngle && currentCharacterType === 'cat') {
                clearInterval(angleInterval);
                angleInterval = null;
                isSettingAngle = false;
                throwObject(currentCharacter);
                currentCharacter = null;
                currentCharacterType = null;
                resetGraphics();
            }
        });

        // ç§»é™¤ç”Ÿæˆå™¨ç›¸é—œåŠŸèƒ½ï¼Œä¿æŒç°¡æ½”

        // å…§å»ºåœ–ç‰‡é¡Œç›®è³‡æ–™
        function loadImageQuestions() {
            // å®šç¾©æ‰€æœ‰å¯ç”¨çš„åœ–ç‰‡å’Œå°æ‡‰ç­”æ¡ˆ
            const imageQuestions = [
                { image: 'pic709/ä¸­.png', answer: 'ä¸­' },
                { image: 'pic709/å±±.png', answer: 'å±±' },
                { image: 'pic709/7.png', answer: '7' },
                { image: 'pic709/0.png', answer: '0' },
                { image: 'pic709/9.png', answer: '9' }
            ];

            // æ‰€æœ‰å¯èƒ½çš„ç­”æ¡ˆé¸é …
            const allAnswers = ['ä¸­', 'å±±', '7', '0', '9'];

            // ç‚ºæ¯å€‹åœ–ç‰‡ç”Ÿæˆé¡Œç›®è³‡æ–™
            questionData = imageQuestions.map(item => ({
                image: item.image,
                correctAnswer: item.answer,
                allOptions: allAnswers
            }));

            questionsLoaded = true;
            console.log(`è¼‰å…¥äº† ${questionData.length} é“åœ–ç‰‡é¡Œç›®`);
        }

        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            loadImageQuestions();
            generateRandomFlowers();
            generateFlyingText();

            // ç­‰é¡Œç›®è¼‰å…¥å®Œæˆå¾Œæ‰é–‹å§‹éŠæˆ²
            if (questionsLoaded) {
                showQuestion();
                gameLoop();
            }
        }

        // å•Ÿå‹•éŠæˆ²
        initGame();
        updateScoreDisplay(); // åˆå§‹åŒ–åˆ†æ•¸é¡¯ç¤º

        // ç§»é™¤èˆŠçš„è§£æå’Œé¡¯ç¤ºå‡½æ•¸

        function showQuestion() {
            if (gameEnded || !questionsLoaded || questionData.length === 0) return;

            if (usedQuestions.length === questionData.length) {
                usedQuestions = [];
            }

            let unusedQuestions = questionData.filter(q => !usedQuestions.includes(q));
            let randomIndex = Math.floor(Math.random() * unusedQuestions.length);
            let currentQuestion = unusedQuestions[randomIndex];
            usedQuestions.push(currentQuestion);

            // è¨­å®šé¡Œç›®æ–‡å­—å’Œåœ–ç‰‡
            questionText.textContent = "è«‹çœ‹åœ–ç‰‡é¸æ“‡ç­”æ¡ˆ";
            const questionImage = document.getElementById('question-image');
            questionImage.src = currentQuestion.image;
            questionImage.alt = "é¡Œç›®åœ–ç‰‡";

            // ç”Ÿæˆå››å€‹ä¸é‡è¤‡çš„é¸é …ï¼Œå…¶ä¸­åŒ…å«æ­£ç¢ºç­”æ¡ˆ
            const correctAnswer = currentQuestion.correctAnswer;
            const allOptions = currentQuestion.allOptions.filter(option => option !== correctAnswer);

            // éš¨æ©Ÿé¸æ“‡3å€‹éŒ¯èª¤é¸é …
            const wrongOptions = [];
            while (wrongOptions.length < 3 && allOptions.length > 0) {
                const randomIndex = Math.floor(Math.random() * allOptions.length);
                const option = allOptions.splice(randomIndex, 1)[0];
                wrongOptions.push(option);
            }

            // çµ„åˆæ‰€æœ‰é¸é …ä¸¦éš¨æ©Ÿæ’åº
            const allChoices = [correctAnswer, ...wrongOptions];
            const shuffledOptions = allChoices.sort(() => Math.random() - 0.5);

            // æ¸…ç©ºä¸¦é‡æ–°ç”Ÿæˆé¸é …æŒ‰éˆ•
            playerOptions.innerHTML = '';

            shuffledOptions.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option;
                button.style.backgroundColor = ['red', 'green', 'blue', 'purple'][index];
                button.addEventListener('click', () => handleAnswer(option));
                playerOptions.appendChild(button);
            });

            questionLayer.style.display = 'block';
        }

        function handleAnswer(selectedOption) {
            const currentQuestion = usedQuestions[usedQuestions.length - 1];

            // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†æ­£ç¢ºç­”æ¡ˆ
            const isCorrect = selectedOption === currentQuestion.correctAnswer;

            console.log('ç©å®¶é¸æ“‡:', selectedOption);
            console.log('æ­£ç¢ºç­”æ¡ˆ:', currentQuestion.correctAnswer);
            console.log('ç­”é¡Œçµæœ:', isCorrect ? 'æ­£ç¢º' : 'éŒ¯èª¤');

            if (isCorrect) {
                // ç©å®¶ç­”å°ï¼Œå¢åŠ é€£çºŒç­”å°æ¬¡æ•¸
                correctStreak++;

                // æª¢æŸ¥ç‰¹æ®Šæ•ˆæœ
                if (correctStreak === 5) {
                    hasShield = true; // ç²å¾—è­·ç›¾
                } else if (correctStreak === 3) {
                    bigBullet = true; // ç²å¾—å¤§å­å½ˆ
                }

                updateScoreDisplay();

                // ç©å®¶ç­”å°ï¼Œå¯ä»¥æ”»æ“Š
                questionLayer.style.display = 'none';
                catCanThrow = true;
                currentCharacter = cat;
                currentCharacterType = 'cat';
                startPowerSetting(currentCharacter);
            } else {
                // ç©å®¶ç­”éŒ¯ï¼Œé‡ç½®é€£çºŒç­”å°æ¬¡æ•¸
                correctStreak = 0;
                // è­·ç›¾ä¸æœƒå› ç‚ºç­”éŒ¯è€Œæ¶ˆå¤±ï¼Œåªæœ‰è¢«æ”»æ“Šæ™‚æ‰æœƒæ¶ˆå¤±
                bigBullet = false; // å¤±å»å¤§å­å½ˆ
                updateScoreDisplay();

                // æ¨™è¨˜éŒ¯èª¤é¸é …ä¸¦è§¸ç™¼é›»è…¦æ”»æ“Š
                const buttons = playerOptions.children;
                for (let button of buttons) {
                    if (button.textContent === selectedOption) {
                        button.style.textDecoration = 'line-through';
                        button.style.opacity = '0.5';
                        button.disabled = true;
                    }
                }

                // å»¶é²ä¸€ä¸‹è®“ç©å®¶çœ‹åˆ°éŒ¯èª¤ï¼Œç„¶å¾Œè§¸ç™¼é›»è…¦æ”»æ“Š
                setTimeout(() => {
                    questionLayer.style.display = 'none';
                    computerAttack();
                }, 1500);
            }
        }

        function resetGraphics() {
            if (currentCharacter) {
                currentCharacter.power = 5;
                currentCharacter.angle = 0;
                clearInterval(powerInterval);
                clearInterval(angleInterval);
                powerInterval = null;
                angleInterval = null;
            }
        }

        // ç§»é™¤ç”Ÿæˆå™¨åˆ‡æ›åŠŸèƒ½

        // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
        function updateScoreDisplay() {
            document.getElementById('hit-count').textContent = playerHitCount;
            document.getElementById('streak-count').textContent = correctStreak;

            // æ›´æ–°é€£çºŒç­”å°ç‹€æ…‹æç¤º
            const streakElement = document.getElementById('streak-count');
            if (hasShield) {
                streakElement.style.color = 'cyan';
                streakElement.title = 'è­·ç›¾å•Ÿå‹•ï¼';
            } else if (bigBullet) {
                streakElement.style.color = 'orange';
                streakElement.title = 'å¤§å­å½ˆæº–å‚™ï¼';
            } else if (correctStreak >= 3) {
                streakElement.style.color = 'yellow';
                streakElement.title = 'å³å°‡ç²å¾—å¤§å­å½ˆï¼';
            } else if (correctStreak >= 4) {
                streakElement.style.color = 'lightgreen';
                streakElement.title = 'å³å°‡ç²å¾—è­·ç›¾ï¼';
            } else {
                streakElement.style.color = 'white';
                streakElement.title = '';
            }
        }

        // é–‹å•Ÿæ»‘é¼ å³éµé¸å–®åŠŸèƒ½
        document.addEventListener('contextmenu', (event) => {
            return true;
        });
    </script>


</body>

</html>